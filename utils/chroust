#!/usr/bin/env php
<?php

if (!isset($_SERVER['SERVER_NAME'])) $_SERVER['SERVER_NAME']='';

$_required_modules = array('iquest', 'auth', 'console');

require_once(dirname(__FILE__)."/../config/set_env.php");
require_once(dirname(__FILE__)."/../functions/functions.php");
require_once(getenv('SERWEB_DIR')."functions/bootstrap.php");

class Iquest_MetadataOpenException extends Exception {}
class Iquest_noMetaDataException extends Iquest_MetadataOpenException {}

class Iquest_InvalidConfigException extends Exception {}
class Iquest_ConfigDirOpenException extends Iquest_InvalidConfigException {}

class Iquest_VerifyFailedException extends Iquest_InvalidConfigException {
    const SOLUTION_IDS = "Solution IDs";
    const CLUE_IDS = "Clue IDs";
    const CLUE_GRP_IDS = "Clue Group IDs";

    private $gathered_info = array();

    public function __construct($message, $gather_info=array()){
        parent::__construct($message);
        
        foreach($gather_info as $info_type){
            $this->gather_info($info_type);
        }
    }

    private function gather_info($info_type){
        $data = array();

        switch($info_type){
        case self::SOLUTION_IDS:
            $solutions = Iquest_Solution::fetch();
            foreach($solutions as $solution) $data[]=$solution->id;
            break;

        case self::CLUE_IDS:
            $clues = Iquest_Clue::fetch();
            foreach($clues as $clue) $data[]=$clue->id;
            break;

        case self::CLUE_GRP_IDS:
            $cluegprs = Iquest_ClueGrp::fetch();
            foreach($cluegprs as $cluegrp) $data[]=$cluegrp->id;
            break;

        default:
            throw new Exception(__CLASS__.":".__FUNCTION__." - Invalid value for info_type '$info_type'");
        }

        $this->gathered_info[$info_type]=$data;
    }


    public function get_info(){
        $str = "";
        foreach($this->gathered_info as $label => $data){
            sort($data);
            $str .= "$label\n";
            $str .= str_repeat("=", strlen($label))."\n";
            $str .= implode(", ", $data)."\n\n";
        }
        return $str;
    }
}

class Iquest_Verbose_Output{
    private static $enabled=false;
    
    public static function enable(){
        self::$enabled=true;
    }

    public static function log($data, $label=""){
        if (!self::$enabled) return;

        if ($label) Console::log("$label: ", Console::LIGHT_GREEN, false, Console::UNDERLINE);
        $str = print_r($data, true);
        Console::log($str, Console::DARK_GRAY);
    }
}

class Iquest_Metadata{

    const METADATA_FILE = "metadata.ini";
    const SOLUTION_ID_PREFIX = "KEY-";

    /** Name of directives in ini file that set the option */
    public static $option_2_ini_file_directive = array(
        Iquest_Options::INITIAL_CGRP_ID       => "start",
        Iquest_Options::FINAL_CGRP_ID         => "final",
        Iquest_Options::REVEAL_GOAL_CGRP_ID   => "reveal_goal",
    ); 

    private $data;
    private $parent_metadata;

    private static $default_cfg = array(
        "clue_pattern"      => "indicie[0-9-]+\\..*",
        "clue_coin_pattern" => "indicie[0-9-]+c\\..*",
        "clue_special_pattern" => "indicie[0-9-]+s\\..*",
        "hint_pattern"      => "napoveda[0-9-]+.*",
        "solution_pattern"  => "reseni.*",
    );

    private static function timeout_to_sec($timeout, $what){

        $timeout = trim($timeout);

        if (!preg_match("/^([0-9]+)([hms]?)$/", $timeout, $matches)){
            throw new Iquest_InvalidConfigException("Invalid timeout value: '$timeout' for $what");
        }

        $value = $matches[1];
        $unit = $matches[2];

        if (!$unit) $unit = "m";

        switch($unit){
        case "s": return (int)$value;
        case "m": return 60*(int)$value;
        case "h": return 3600*(int)$value;
        default:
            throw new Iquest_InvalidConfigException("Invalid unit of timeout: '$timeout' for $what");
        }

    }

    function __construct($dir, $parent_metadata=null){
        $this->data             = $this->get_metadata($dir.self::METADATA_FILE);
        $this->parent_metadata  = $parent_metadata;
    }

    private function get_metadata($file){
        if (!file_exists($file)) throw new Iquest_noMetaDataException();
        
        $metadata = parse_ini_file($file, true);
        if (false === $metadata){
            throw new Iquest_MetadataOpenException("Cannot open or read metadata file: ".$file);
        }
        return $metadata;
    }

    function get_cfg(){
        // start with default configuration
        if ($this->parent_metadata){
            $cfg = $this->parent_metadata->get_cfg();
        }
        else{
            $cfg = self::$default_cfg;
        }

        // replace all values specified in metadata file
        foreach($cfg as $k => $v){
            if (isset($this->data['cfg'][$k])){
                $cfg[$k] = $this->data['cfg'][$k];
            }
        }
        
        return $cfg;
    }

    /**
     *  Return charset used in for specific file
     *  
     *  Function first look to [$filename] section and if it do not contain 
     *  the charset, it look to [general] section.               
     */         
    function get_charset($filename){
        
        $filename = basename($filename);
        if (isset($this->data["file:".$filename]['charset'])){
            return $this->data["file:".$filename]['charset'];
        }

        if (isset($this->data['general']['charset'])){
            return $this->data['general']['charset'];
        }

        if ($this->parent_metadata){
            return $this->parent_metadata->get_charset($filename);
        }

        throw new Iquest_InvalidConfigException("Charset not specified in metadata file.");
    }

    /**
     *  Return MIME type used in for specific file
     *  
     *  Function first look to [$filename] section and if it do not contain 
     *  the MIME type it call Iquest_file::get_mime_type()               
     */         
    function get_mime_type($filename){
        
        $filename = basename($filename);
        if (isset($this->data["file:".$filename]['mime_type'])){
            return $this->data["file:".$filename]['mime_type'];
        }

        return Iquest_file::get_mime_type($filename);
    }

    function get_cgrp_id(){
        if (!isset($this->data['general']['id'])){
            throw new Iquest_InvalidConfigException("ID not specified in metadata file.");
        }
        return $this->data['general']['id'];
    }
    
    function get_cgrp_name(){

        if (!isset($this->data['cgrp']['name'])){
            throw new Iquest_InvalidConfigException("name for clue group is not set.");
        }

        $charset = $this->get_charset(self::METADATA_FILE);
        if ($charset != "UTF-8"){
            return iconv($charset, "UTF-8", $this->data['cgrp']['name']);
        }

        return $this->data['cgrp']['name'];
    }
    
    function get_cgrp_order(){

        if (!isset($this->data['cgrp']['order'])){
            Console::log( "*** WARNING: order for clue group is not set.", Console::YELLOW);
            return 0;
        }

        return $this->data['cgrp']['order'];
    }

    function is_start_cgrp(){
        return !empty($this->data['cgrp']['start']);
    }

    function is_reveal_goal_cgrp(){
        return !empty($this->data['cgrp']['reveal_goal']);
    }

    function is_final_cgrp(){
        return !empty($this->data['cgrp']['final']);
    }

    function get_solution_id(){
        if (isset($this->data['solution']['id'])){
            return $this->data['solution']['id'];
        }

        $next_cgrp = $this->get_solution_next_cgrp();
        if ($next_cgrp) return self::SOLUTION_ID_PREFIX.$next_cgrp;

        return $this->get_cgrp_id();
    }

    function get_solution_name(){

        if (!isset($this->data['solution']['name'])){
            return $this->get_cgrp_name();
        }

        $charset = $this->get_charset(self::METADATA_FILE);
        if ($charset != "UTF-8"){
            return iconv($charset, "UTF-8", $this->data['solution']['name']);
        }

        return $this->data['solution']['name'];
    }

    function get_solution_key(){
        if (!isset($this->data['solution']['key'])){
            throw new Iquest_InvalidConfigException("Solution key is not set.");
        }

        $charset = $this->get_charset(self::METADATA_FILE);
        if ($charset != "UTF-8"){
            return iconv($charset, "UTF-8", $this->data['solution']['key']);
        }

        return $this->data['solution']['key'];
    }

    function is_key_set(){
        return !empty($this->data['solution']['key']);
    }

    /**
     *  Get canonicalized key
     */         
    function get_solution_key_canon(){
        return Iquest_Solution::canonicalize_key($this->get_solution_key());
    }

    function get_solution_timeout(){
        if (!isset($this->data['solution']['timeout'])){
            return 0;
        }
        return self::timeout_to_sec($this->data['solution']['timeout'], "solution"); 
    }

    function get_solution_countdown_start(){
        if (!isset($this->data['solution']['countdown_start'])){
            return Iquest_Solution::CD_START_ALL;
        }

        if (!in_array($this->data['solution']['countdown_start'],
                      array(Iquest_Solution::CD_START_ALL,
                            Iquest_Solution::CD_START_SINGLE))){

            throw new Iquest_InvalidConfigException("Invalid value '{$this->data['solution']['countdown_start']}' for countdown_start.");
        }

        return $this->data['solution']['countdown_start']; 
    }

    function get_solution_coin_value(){
        if (!isset($this->data['solution']['coin_value'])){
            return 0;
        }
        return round($this->data['solution']['coin_value'],2);
    }

    function get_solution_next_cgrp(){
        if (!isset($this->data['solution']['next_cgrp_id'])){
            return null;
        }
        return $this->data['solution']['next_cgrp_id'];
    }

    /**
     *  Return number of hidden clues
     */         
    function get_clue_hidden_nr(){
        if (!isset($this->data['cgrp']['hidden_clues'])) return 0;
        
        return (int)$this->data['cgrp']['hidden_clues'];
    }
    
    function get_clue_point_to($clue_nr){
        // If no point_to is specifed for the clue, assume it point to 
        // solution specified in this directory 
        if (!isset($this->data['clue']['point_to'][$clue_nr])){
            return array($this->get_solution_id());
        } 
        
        $point_to = $this->data['clue']['point_to'][$clue_nr];

        // If point_to is "-" or "" it point to no solution
        if ($point_to == "-" or $point_to == "") return array(); 

        // Otherwise create array from the comma separated list
        return explode(",", $point_to); 
    }


    function get_clue_type($clue_nr, $filename){
        $cfg = $this->get_cfg();

        $clue_type = Iquest_Clue::TYPE_REGULAR;
        if (!$filename){
            $clue_type = Iquest_Clue::TYPE_HIDDEN;
        }
        elseif (preg_match("/".$cfg["clue_coin_pattern"]."/i", basename($filename))){
            $clue_type = Iquest_Clue::TYPE_COIN;
        }
        elseif (preg_match("/".$cfg["clue_special_pattern"]."/i", basename($filename))){
            $clue_type = Iquest_Clue::TYPE_SPECIAL;
        }

        return $clue_type;
    }


    /**
     *  Retrieve the clue ID for given hint number
     *  Return null if clue ids are not specified
     */         
    function get_hint_clueid($hint_nr){
        if (!isset($this->data['hint']['clue_IDs']) or 
            trim($this->data['hint']['clue_IDs']) == ""){
            
            return null;
        }
        
        $clue_IDs = explode(",", $this->data['hint']['clue_IDs']);

        if (trim($clue_IDs[0]) == ""){
            return null;
        }
        
        if (!isset($clue_IDs[$hint_nr])){
            $clue_ID = (int)end($clue_IDs);
            $clue_ID = $this->get_cgrp_id()."-".$clue_ID; 
        }
        else{
            $clue_ID = (int)$clue_IDs[$hint_nr];
            $clue_ID = $this->get_cgrp_id()."-".$clue_ID; 
        }

        return $clue_ID;
    }

    function get_hint_timeout($hint_nr){
        if (!isset($this->data['hint']['timeouts']) or 
            trim($this->data['hint']['timeouts']) == ""){

            $this->data['hint']['timeouts'] = "";
        }
        
        $timeouts = explode(",", $this->data['hint']['timeouts']);


        if (!isset($timeouts[$hint_nr])){
            $timeout = end($timeouts);
            if (!$timeout) $timeout=0; // for the case the array is empty
        }
        else{
            $timeout = $timeouts[$hint_nr];
        }

        if ($timeout == "") $timeout = 0;

        return self::timeout_to_sec($timeout, "hint $hint_nr"); 
    }

    function get_hint_price($hint_nr){
        if (!isset($this->data['hint']['prices']) or 
            trim($this->data['hint']['prices']) == ""){

            $this->data['hint']['prices'] = "";
        }
        
        $prices = explode(",", $this->data['hint']['prices']);

        if (!isset($prices[$hint_nr])){
            $price = 0;
        }
        else{
            $price = $prices[$hint_nr];
        }
        
        if ($price == "") $price = 0;

        if (!is_numeric($price)){
            throw new Iquest_InvalidConfigException("Invalid price value: '$price' for hint $hint_nr");
        }

        return round($price, 2);
    }

    
    function save_options(){
        if (!isset($this->data['options'])) return;
        if (!is_array($this->data['options'])) return;

        foreach($this->data['options'] as $name=>$value){
            if ($name == Iquest_Options::COUNTDOWN_LIMIT_HINT or
                $name == Iquest_Options::COUNTDOWN_LIMIT_SOLUTION or
                $name == Iquest_Options::HIDE_PLACE_TIMEOUT){

                $value = self::timeout_to_sec($value, "option $name");
            }

            Iquest_Options::set($name, $value);
        }
    }

    function to_string(){
        $cfg = $this->get_cfg();

        $str = "\n";

        $str .= "** FOLDER CFG:\n";
        foreach($cfg as $key=>$val){
            $key = strtoupper($key);
            $str .= "   $key: $val\n";
        }

        try                                     {$cgrp_id=$this->get_cgrp_id();}
        catch(Iquest_InvalidConfigException $e) {$cgrp_id = "---";}

        try                                     {$cgrp_name=$this->get_cgrp_name();}
        catch(Iquest_InvalidConfigException $e) {$cgrp_name = "---";}

        $str .= "** CLUE GROUP:\n";
        $str .= "   ID: ".$cgrp_id.
                  " NAME: ".$cgrp_name.
                  " ORDER: ".$this->get_cgrp_order()."\n";
        $str .= "   START: ".$this->is_start_cgrp().
                  " FINAL: ".$this->is_final_cgrp().
                  " GIVE IT UP: ".$this->is_reveal_goal_cgrp()."\n";

        $str .= "** SOLUTION:\n";
        $str .= "   ID: ".$this->get_solution_id().
                  " NAME: ".$this->get_solution_name().
                  ($this->is_key_set()?" KEY: ".$this->get_solution_key():"")."\n";
        $str .= "   TIMEOUT: ".$this->get_solution_timeout().
                  " COUNTDOWN START: ".$this->get_solution_countdown_start().
                  " COIN VALUE: ".$this->get_solution_coin_value().
                  " NEXT CGRP ID: ".$this->get_solution_next_cgrp()."\n";

        $str .= "** CLUES:\n";
        $str .= "   NR HIDDEN CLUES: ".$this->get_clue_hidden_nr()."\n";
        
        return $str;
    }
}


class Chroust{

    static $summary = array(
                        'keys'  => array(),
                        'hints' => array(),
                      );
    static $unknown_files = array();

    static $id2ref_id = array();


    static function prune_data_dir(){
        global $config;

        if ($config->iquest_data_dir and $config->iquest_data_dir != "/"){
            Console::log("Erasing content of directory: ".$config->iquest_data_dir, Console::YELLOW);

            // make sure the destination directory is empty
            rm($config->iquest_data_dir."*");
        }
        else {
            throw new Exception("Iquest datadir is not set in config file.");            
        }
    }

    static function prune_db($option){
        global $data, $config;
    
        $tables = array(
            $config->data_sql->iquest_cgrp->table_name,
            $config->data_sql->iquest_clue->table_name,
            $config->data_sql->iquest_clue2solution->table_name,
            $config->data_sql->iquest_hint->table_name,
            $config->data_sql->iquest_solution->table_name,
            $config->data_sql->iquest_option->table_name,
        );

        if (empty($option['preserve-user-data'])){
            $tables[] = $config->data_sql->iquest_cgrp_open->table_name;
            $tables[] = $config->data_sql->iquest_hint_team->table_name;
            $tables[] = $config->data_sql->iquest_solution_team->table_name;
            $tables[] = $config->data_sql->iquest_event->table_name;
            $tables[] = $config->data_sql->iquest_team_rank->table_name;
        }

        foreach($tables as $table){
            Console::log("Erasing DB table: ".$table, Console::YELLOW);
            $res=$data->db->query("delete from ".$table);
            if ($data->dbIsError($res)) throw new DBException($res);
        }

        if (empty($option['preserve-user-data'])){
            Console::log("Wiping user wallets", Console::YELLOW);
            $res=$data->db->query(
                "update {$config->data_sql->iquest_team->table_name} 
                 set {$config->data_sql->iquest_team->cols->wallet}=0");
            if ($data->dbIsError($res)) throw new DBException($res);
        }    
    }

    static function save_ref_ids($option){

        if (empty($option['preserve-user-data'])) return;

        Iquest_Verbose_Output::log("Saving ref_ids from DB tables");

        $cgrps = Iquest_ClueGrp::fetch();
        $clues = Iquest_Clue::fetch();
        $hints = Iquest_Hint::fetch();
        $solutions = Iquest_Solution::fetch();
        
        foreach($cgrps as $cgrp)            self::$id2ref_id['cgrp'][$cgrp->id]         = $cgrp->ref_id;
        foreach($clues as $clue)            self::$id2ref_id['clue'][$clue->id]         = $clue->ref_id;
        foreach($hints as $hint)            self::$id2ref_id['hint'][$hint->id]         = $hint->ref_id;
        foreach($solutions as $solution)    self::$id2ref_id['solution'][$solution->id] = $solution->ref_id;
    }


    /**
     *  Set default values for options
     */         
    static function set_defaults(){
        Iquest_Options::set(Iquest_Options::CHECK_KEY_ORDER, 0);
        Iquest_Options::set(Iquest_Options::SHOW_PLACE, 1);
        Iquest_Options::set(Iquest_Options::HIDE_PLACE_TIMEOUT, 0);
        Iquest_Options::set(Iquest_Options::SHOW_GRAPH, 1);
        Iquest_Options::set(Iquest_Options::SHOW_GRAPH_CGRP_NAMES, 0);
        Iquest_Options::set(Iquest_Options::KEY_PREFIX, "");
    }

    /**
     *  Create initial record for team ranking.
     */         
    static function init_team_rank($option){

        $ranks = Iquest_team_rank::fetch();

        // Do it only when user data are not preserved or team_rank DB table is empty
        if (!empty($option['preserve-user-data']) and count($ranks)){
            return;
        }
        
        $teams = Iquest_Team::fetch();

        $team_nr = count($teams);
        $distances = array();
        $rank = array();

        foreach($teams as $team){
            $distances[$team->id] = "999999";
            $rank[$team->id] = $team_nr;
        }

        $start_time = Iquest_Options::get(Iquest_Options::START_TIME);

        $team_rank = new Iquest_team_rank($start_time, $distances, $rank, null);
        $team_rank->insert();
    }
    
    static function insert_cgrp($metadata){
        $cgrp_id = $metadata->get_cgrp_id();
        $cgrp_name = $metadata->get_cgrp_name();
        $cgrp_order = $metadata->get_cgrp_order();

        if (isset(self::$id2ref_id['cgrp'][$cgrp_id])) $ref_id = self::$id2ref_id['cgrp'][$cgrp_id];
        else                                           $ref_id = rfc4122_uuid();
        
        $cgrp = new Iquest_ClueGrp($cgrp_id, $ref_id, $cgrp_name, $cgrp_order);
        $cgrp->insert();
        return $cgrp;
    }

    static function insert_clue($filename, $clue_nr, $metadata){
        $cgrp_id = $metadata->get_cgrp_id();
        $clue_id = $cgrp_id."-".$clue_nr;

        if (isset(self::$id2ref_id['clue'][$clue_id])) $ref_id = self::$id2ref_id['clue'][$clue_id];
        else                                           $ref_id = rfc4122_uuid();

        $content_type = $metadata->get_mime_type($filename);
        $point_to = $metadata->get_clue_point_to($clue_nr);
        $clue_type = $metadata->get_clue_type($clue_nr, $filename);

        $clue = new Iquest_Clue($clue_id, $ref_id, 
                $filename, $content_type, $clue_type,
                null, $cgrp_id, $clue_nr, $point_to);

        $clue->insert();
        return $clue;
    }

    static function insert_hint($filename, $hint_nr, $metadata, $clues){
        $cgrp_id = $metadata->get_cgrp_id();
        $hint_id = $cgrp_id."-".$hint_nr;

        if (isset(self::$id2ref_id['hint'][$hint_id])) $ref_id = self::$id2ref_id['hint'][$hint_id];
        else                                           $ref_id = rfc4122_uuid();

        $content_type = $metadata->get_mime_type($filename);
        $clue_id = $metadata->get_hint_clueid($hint_nr);
        $timeout = $metadata->get_hint_timeout($hint_nr);
        $price = $metadata->get_hint_price($hint_nr);

        // if clue ID is not specified, use the ID of last clue
        if (is_null($clue_id)){
            $last_clue = end($clues);
            $clue_id = $last_clue->id;

            Console::log("*** WARNING: clue_IDs are not specified for hint. Useing '$clue_id'", Console::YELLOW);
        }

        // Check whether the clue ID is valid
        if (!isset($clues[$clue_id])){
            throw new Iquest_InvalidConfigException("Invalid clue_ID '$clue_id' specified for a hint.");
        }

        if (!$timeout and !$price){
            throw new Iquest_InvalidConfigException("Neither timeout nor price is specified for hint '$hint_nr'. This hint will never be shown.");
        }

        self::$summary['hints'][] = array("cgrp_name" => $metadata->get_cgrp_name(),
                                          "ordering"  => $metadata->get_cgrp_order(),
                                          "clue_id"   => $clue_id,
                                          "hint_nr"   => $hint_nr,
                                          "price"     => $price,
                                          "timeout"   => $timeout);


        $hint = new Iquest_Hint($hint_id, $ref_id, 
                $filename, $content_type, null, $clue_id, $timeout, $price, $hint_nr);

        $hint->insert();
        return $hint;
    }

    static function insert_solution($filename, $solution_nr, $metadata){

        if ($solution_nr > 0){
            Console::log("*** WARNING: Only one solution file allowed in a directory. Ignoring the another one: '$filename'", Console::YELLOW);
            return null; 
        }

        $solution_id = $metadata->get_solution_id();

        if (isset(self::$id2ref_id['solution'][$solution_id])) $ref_id = self::$id2ref_id['solution'][$solution_id];
        else                                                   $ref_id = rfc4122_uuid();

        $content_type = $metadata->get_mime_type($filename);

        $name = $metadata->get_solution_name();
        $key = $metadata->get_solution_key_canon();
        $timeout = $metadata->get_solution_timeout();
        $countdown_start = $metadata->get_solution_countdown_start();
        $next_cgrp_id = $metadata->get_solution_next_cgrp();
        $coin_value = $metadata->get_solution_coin_value();

        if (!$filename and $timeout > 0){
            throw new Iquest_InvalidConfigException("No solution file exists, but timeout (for displaying it) is set.");
        }

        $stub = false;
        if (!$next_cgrp_id){
            $stub = true;
            $next_cgrp_id = $solution_id."#STUB"; // generate and ID for clue group.
                                              // This ID does not exists in clue_group table
                                              // but is used in open_cgrp table to mark
                                              // gained solutions. 
        }

        self::$summary['keys'][] = array("name" => $name,
                                         "key"  => $metadata->get_solution_key(),
                                         "ordering" => $metadata->get_cgrp_order(),
                                         "coin_value" => $coin_value,
                                         "timeout" =>    $timeout,
                                         "next_cgrp_id" => $stub ? null : $next_cgrp_id);

        $solution = new Iquest_Solution($solution_id, $ref_id, 
                $filename, $content_type, null, $name, $next_cgrp_id, $timeout, 
                $countdown_start, $key, $coin_value, $stub);

        $solution->insert();
        return $solution;
    }

    
    static function process_top_metadata($dir){

        try{
            $metadata = new Iquest_Metadata($dir);
        }
        catch (Iquest_noMetaDataException $e){
            throw new Iquest_InvalidConfigException("Cannot find top metadata file in directory: ".$dir, 0 ,$e);
        }
    
        try{
            $metadata->save_options();
        }
        catch(Iquest_MetadataOpenException $e){
            throw new Iquest_InvalidConfigException("Problem reading metadata of directory: ".$dir, 0 ,$e);
        }
        
        return $metadata;
    }

    static function process_data_dir($src_dir){

        $top_metadata = self::process_top_metadata($src_dir);

        $dir = scandir($src_dir, SCANDIR_SORT_ASCENDING);
        if ($dir === false) throw new Iquest_ConfigDirOpenException("Cannot open directory: ".$src_dir);

        foreach($dir as $entry){
            //skip entries that are not directories
            if (!is_dir($src_dir.$entry)) continue; 
            if (substr($entry, 0, 1) == ".") continue; 

            try{
                $dest_dir = self::canonicalize_name($entry);
                self::process_task_dir($src_dir.$entry.DIRECTORY_SEPARATOR, $dest_dir, $top_metadata);
            }
            catch(Iquest_MetadataOpenException $e){
                throw new Iquest_InvalidConfigException("Problem during processing directory: ".$src_dir.$entry.DIRECTORY_SEPARATOR, 0, $e);
            }
        }
    
    }

    static private function filename_replacement(&$line, &$files, $filename){
        while (preg_match("/<file-(?P<type>[a-z])(?P<nr>[0-9])+>/i", $line, $matches)){

            if ($matches['type']=='c') $type='clues';
            elseif ($matches['type']=='h') $type='hints';
            elseif ($matches['type']=='s') $type='solutions';
            else{
                throw new Iquest_InvalidConfigException("Invalid file replacement '{$matches[0]}' in file '$filename'");
            }
            
            $nr = $matches['nr'] - 1;
            $filenames = array_keys($files[$type]);
            if (!isset($filenames[$nr])){
                throw new Iquest_InvalidConfigException("Cannot find file number '{$matches['nr']}' for file replacement '{$matches[0]}' in file '$filename'");
            }
    
            $line = str_replace($matches[0], $filenames[$nr], $line);
        }
    }

    static function copy_file($from, $to, $file_obj, $metadata, $files){
        global $config;

        if (substr($file_obj->content_type, 0, 5) == "text/"){
            $charset = $metadata->get_charset($file_obj->filename);

            $in =  fopen($from, "r");
            $out = fopen($config->iquest_data_dir.$to, "w");

            while($line = fgets($in)) {
                if ($charset != "UTF-8"){
                    $line = iconv($charset, "UTF-8", $line);
                }

                if (is_a($file_obj, "Iquest_Solution")){
                    $line = str_replace("<key>", $metadata->get_solution_key(), $line);
                }

                self::filename_replacement($line, $files, basename($from));

                if (false === fwrite($out, $line)){
                    throw new Exception("Copy of file $from failed");
                }
            }

            if (!feof($in)) {
                throw new Exception("Copy of file $from failed");
            }


            fclose($in);            
            fclose($out);            
            return;
        }
        
        if (!copy($from, $config->iquest_data_dir.$to)){
            throw new Exception("Copy of file $from failed");
        }
    }

    static function process_task_dir($task_dir, $dest_dir, $top_metadata){
        global $config;
        
        Console::log("Reading directory: $task_dir", Console::GREEN);

        try{
            $metadata = new Iquest_Metadata($task_dir, $top_metadata);
        }
        catch (Iquest_noMetaDataException $e){
            Console::log("*** No metadata. Skipping!!!", Console::YELLOW);
            return;
        }

        Iquest_Verbose_Output::log($metadata->to_string(), "Metadata");
        
        // re-create the dest. dir 
        RecursiveMkdir($config->iquest_data_dir.$dest_dir);
        
        $dir = scandir($task_dir, SCANDIR_SORT_ASCENDING);
        if ($dir === false) throw new Iquest_ConfigDirOpenException("Cannot open directory: ".$task_dir);

        $cfg = $metadata->get_cfg();
        $entries=array();
        $entries['clues']=array();
        $entries['hints']=array();
        $entries['solutions']=array();
        
        foreach($dir as $entry){
            //skip entries that are not files
            if (!is_file($task_dir.$entry)) continue;
            // skip metadata file
            if ($entry == Iquest_Metadata::METADATA_FILE) continue; 
        
            $dest_file = self::canonicalize_name($entry);

            if (preg_match("/".$cfg["clue_pattern"]."/i", $dest_file) or
                preg_match("/".$cfg["clue_coin_pattern"]."/i", $dest_file) or
                preg_match("/".$cfg["clue_special_pattern"]."/i", $dest_file)){
                $entries['clues'][$entry] = $dest_file;
            }
            elseif (preg_match("/".$cfg["hint_pattern"]."/i", $dest_file)){
                $entries['hints'][$entry] = $dest_file;
            }
            elseif (preg_match("/".$cfg["solution_pattern"]."/i", $dest_file)){
                $entries['solutions'][$entry] = $dest_file;
            }
            else{
                self::$unknown_files[] = $task_dir.$entry;
            }
        }

        Iquest_Verbose_Output::log($entries, "Read data");

        asort($entries['clues']);
        asort($entries['hints']);
        asort($entries['solutions']);

        //Create clue group only if it contain at least one clue
        if ($entries['clues']) {
            self::insert_cgrp($metadata);

            if ($metadata->is_start_cgrp()){
                Iquest_Options::set(Iquest_Options::INITIAL_CGRP_ID, $metadata->get_cgrp_id());
            }
    
            if ($metadata->is_reveal_goal_cgrp()){
                Iquest_Options::set(Iquest_Options::REVEAL_GOAL_CGRP_ID, $metadata->get_cgrp_id());
            }
    
            if ($metadata->is_final_cgrp()){
                Iquest_Options::set(Iquest_Options::FINAL_CGRP_ID, $metadata->get_cgrp_id());
            }
        }


        $clue_nr = $hint_nr = $solution_nr = 0;

        $clues = array();
        foreach($entries['clues'] as $from_file=>$to_file){
            $clue = self::insert_clue($dest_dir.DIRECTORY_SEPARATOR.$to_file, $clue_nr, $metadata);
            if (!$clue) continue;

            self::copy_file($task_dir.$from_file, $dest_dir.DIRECTORY_SEPARATOR.$to_file, $clue, $metadata, $entries);

            $clues[$clue->id] = $clue;
            $clue_nr++;
        }

        // generate hidden clues
        $hidden_clues = $metadata->get_clue_hidden_nr();
        for($i=0; $i<$hidden_clues; $i++){
            $clue = self::insert_clue(null, $clue_nr, $metadata);
            if (!$clue) continue;

            $clues[$clue->id] = $clue;
            $clue_nr++;
        }

        $hints = array();
        foreach($entries['hints'] as $from_file=>$to_file){
            $hint = self::insert_hint($dest_dir.DIRECTORY_SEPARATOR.$to_file, $hint_nr, $metadata, $clues);
            if (!$hint) continue;

            self::copy_file($task_dir.$from_file, $dest_dir.DIRECTORY_SEPARATOR.$to_file, $hint, $metadata, $entries);

            $hints[$hint->id] = $hint;
            $hint_nr++;
        }

        $solutions = array();
        foreach($entries['solutions'] as $from_file=>$to_file){
            $solution = self::insert_solution($dest_dir.DIRECTORY_SEPARATOR.$to_file, $solution_nr, $metadata);
            if (!$solution) continue;

            self::copy_file($task_dir.$from_file, $dest_dir.DIRECTORY_SEPARATOR.$to_file, $solution, $metadata, $entries);

            $solutions[$solution->id] = $solution;
            $solution_nr++;
        }

        // If there is no solution file in the directory, but a key is set in metadata...
        if (!$entries['solutions'] and $metadata->is_key_set()){
            // Create the solution record
            $solution = self::insert_solution(null, $solution_nr, $metadata);
            if ($solution){
                $solutions[$solution->id] = $solution;
            }
        }

        
    }

    /**
     *  Set value of WALLET_ACTIVE option in dependency whether 
     *  there are any hints that could be bought
     */         
    static function set_wallet_active(){
        // Check whether the WALLET_ACTIVE is already set from metadata file. If so
        // just return. Otherwise catch the exception thrown and set the WALLET_ACTIVE flag.
        try{
            $option_value = Iquest_Options::get(Iquest_Options::WALLET_ACTIVE);
            return;
        }
        catch(RuntimeException $e){}

        $coin_value = 0;
    
        foreach(self::$summary['hints'] as $row){
            $coin_value += $row['price'];
        }
        
        Iquest_Options::set(Iquest_Options::WALLET_ACTIVE, ($coin_value>0) ? 1 : 0);
    }

    static function verify(){
        global $data, $config;

        $cgrps = Iquest_ClueGrp::fetch();
        $clues = Iquest_Clue::fetch();
        $solutions = Iquest_Solution::fetch();
        
        // verify that next_cgrp_id for each solution is valid (exists)
        foreach($solutions as $solution){
            if (!$solution->stub and !isset($cgrps[$solution->cgrp_id])){
                throw new Iquest_VerifyFailedException(
                            "Task solution '{$solution->id}' reference non existing clue group '{$solution->cgrp_id}'.",
                            array(Iquest_VerifyFailedException::CLUE_GRP_IDS)
                );            
            }
        }
        
        
        
        // verify that clue2soultion point to existing solution

        /* table's name */
        $t_name = &$config->data_sql->iquest_clue2solution->table_name;
        /* col names */
        $c      = &$config->data_sql->iquest_clue2solution->cols;

        // fetch the whole clue2solution DB table
        $q = "select ".$c->clue_id.",
                     ".$c->solution_id."
              from ".$t_name;
    
        $res=$data->db->query($q);
        if ($data->dbIsError($res)) throw new DBException($res);

        // walk through the rows
        while ($row=$res->fetchRow(MDB2_FETCHMODE_ASSOC)){
            if (!isset($solutions[$row[$c->solution_id]])){
                throw new Iquest_VerifyFailedException(
                            "Clue2solution '{$row[$c->clue_id]}, {$row[$c->solution_id]}' reference non existing solution '{$row[$c->solution_id]}'.",
                            array(Iquest_VerifyFailedException::SOLUTION_IDS)
                );            
            }

            if (!isset($clues[$row[$c->clue_id]])){
                throw new Iquest_VerifyFailedException(
                            "Clue2solution '{$row[$c->clue_id]}, {$row[$c->solution_id]}' reference non existing clue '{$row[$c->clue_id]}'.",
                            array(Iquest_VerifyFailedException::CLUE_IDS)
                );
            }

        }
        $res->free();


        //check that all Iquest_Options are set
        foreach(Iquest_Options::$supported_options as $option_name){
            try{
                $option_value = Iquest_Options::get($option_name);
            }
            catch(RuntimeException $e){
                echo "\n";
                Console::log("\n*** ERROR: Option $option_name is not set.", Console::RED);
                
                if (in_array($option_name, Iquest_Options::$set_in_global_ini)){
                    echo "It should be specified in [options] section of metadata in top directory.\n";
                }
                else{
                    echo "It should be specified in [cgrp] section of metadata in the appropriate clue-grp directory.\n";
                }

                if (isset(Iquest_Metadata::$option_2_ini_file_directive[$option_name])){
                    echo "You should set the directive '".Iquest_Metadata::$option_2_ini_file_directive[$option_name]."'.\n";
                }
                
                throw new Iquest_InvalidConfigException($e->getMessage());
            }
        }
        
        // Verify that the graph of clues and solutions is continuous.
        // Use any fake number as team_id. We do not need to have graph for any team. 
        $graph = new Iquest_solution_graph(9999);
        $graph_errors = $graph->check_graph_continuous();
        if ($graph_errors){
            Console::log("\n".str_repeat("*", 80), Console::LIGHT_PURPLE);
            Console::log("The graph of clues and solutions is not continuous.", Console::LIGHT_PURPLE);
            Console::log("Some nodes are not accessible from initial clue group.", Console::LIGHT_PURPLE);
            Console::log("It seems your configuration is not correct.", Console::LIGHT_PURPLE);
            Console::log("You can check the graph in the HQ interface by click on name of any team.\n", Console::LIGHT_PURPLE);
            Console::log($graph_errors, Console::LIGHT_PURPLE);
            Console::log(str_repeat("*", 80), Console::LIGHT_PURPLE);
        }        
    }

    static function canonicalize_name($str){
        $str = remove_diacritics($str);
        $str = strtolower($str);
        $str = str_replace(" ", "_", $str);
        $str = preg_replace("/[^-_a-z0-9.]/", "", $str);
        return $str;
    }

    static function report_errors($e){
        if (is_a($e, "PearErrorException")){
            fwrite(STDERR, $e->pear_err->getMessage()." - ".$e->pear_err->getUserInfo()."\n");
        }
        else{
            fwrite(STDERR, $e->getMessage()."\n");
        }
        if ($e->getPrevious()) self::report_errors($e->getPrevious());
    }

    static function utf_8_sprintf ($format) {
        $args = func_get_args();
        
        for ($i = 1; $i < count($args); $i++) {
            $args [$i] = iconv('UTF-8', 'ISO-8859-2', $args [$i]);
        }
        
        return iconv('ISO-8859-2', 'UTF-8', call_user_func_array('sprintf', $args));
    }
    
    static function format_time($t){
        return sprintf("%02d%s%02d%s%02d", 
                            floor($t/3600), ':', 
                            ($t/60)%60,     ':', 
                            $t%60);
    }
    
    static function usage(){
        echo "Usage: ".$_SERVER['argv'][0]." [--verbose] [--preserve-user-data|--clear-user-data] <datadir> \n\n";
    }
    
    static function main(){
    
        if (posix_getuid() == 0){
            fwrite(STDERR, "Execution as root is not allowed\n");
            exit(1);
        }

        if ($_SERVER['argc'] < 2){
            self::usage();
            exit;
        }

        $option = array('preserve-user-data' => true);
        $src_dir = null;

        for ($i = 1; $i < $_SERVER["argc"]; $i++){
            switch($_SERVER["argv"][$i]){
            case "--preserve-user-data":
                $option['preserve-user-data'] = true;
                break;

            case "--clear-user-data":
                $option['preserve-user-data'] = false;
                break;

            case "-v":
            case "--verbose":
                Iquest_Verbose_Output::enable();
                break;

            default:
                if ($src_dir){  // src dir is already set - it acnnot be set twice
                    self::usage();
                    exit;
                }
                $src_dir = $_SERVER["argv"][$i];
            }
        }

        if (!$src_dir){  // src dir is not set, exit
            self::usage();
            fwrite(STDERR, "The src_dir is not set.\n");
            exit;
        }
        
        if (!is_dir($src_dir)){
            fwrite(STDERR, "The directory does not exists ($src_dir)\n");
            exit(1);
        }
    
        if (substr($src_dir, -1) != DIRECTORY_SEPARATOR){
            $src_dir.=DIRECTORY_SEPARATOR;
        }

        umask(002);
        
        try{
            self::save_ref_ids($option);
            self::prune_data_dir();
            self::prune_db($option);
            self::set_defaults();
            self::process_data_dir($src_dir);

            if (self::$unknown_files){
                echo "\n";
                Console::log("\nNot recognized files:\n", Console::YELLOW);
                foreach(self::$unknown_files as $file){
                    Console::log("  * $file", Console::NORMAL);
                }
            }

            self::set_wallet_active();

            self::verify();

            self::init_team_rank($option);






            echo "\n";
            Console::log("Hint summary:", Console::LIGHT_GREEN, false, Console::UNDERLINE);
            echo "\n";
            
            // sort the keys summary by 'ordering' attribute
            usort(self::$summary['hints'], create_function('$a,$b','
                if ($a["ordering"] == $b["ordering"]) {
                    if ($a["clue_id"] == $b["clue_id"]) {
                        if ($a["hint_nr"] == $b["hint_nr"]) {return 0;}
                        return ($a["hint_nr"] < $b["hint_nr"]) ? -1 : 1;
                    }
                    return ($a["clue_id"] < $b["clue_id"]) ? -1 : 1;
                }
                return ($a["ordering"] < $b["ordering"]) ? -1 : 1;
            '));

            $fields_headers = array('cgrp_name' => "Cgrp Name ", 
                                    'clue_id'   => "Clue ID ", 
                                    'hint_nr'   => "Hint Nr ", 
                                    'price'     => "Price ", 
                                    'timeout'   => "Timeout ",
                                    );
            $fields_widths = self::get_field_widths(self::$summary['hints'], $fields_headers);

            self::print_table_heading($fields_headers, $fields_widths);
            self::print_table_separator($fields_widths);
            
            $fstring = self::get_formating_string($fields_widths, "|");

            foreach(self::$summary['hints'] as $row){
                echo self::utf_8_sprintf($fstring, 
                            $row['cgrp_name'], 
                            $row['clue_id'], 
                            $row['hint_nr'], 
                            $row['price']>0?$row['price']:"---",
                            $row['timeout']>0?gmdate("H:i:s", $row['timeout']):"---");
            }

            self::print_table_separator($fields_widths);






            echo "\n";
            Console::log("Keys summary:", Console::LIGHT_GREEN, false, Console::UNDERLINE);
            echo "\n";

            // sort the keys summary by 'ordering' attribute
            usort(self::$summary['keys'], create_function('$a,$b','
                if ($a["ordering"] == $b["ordering"]) {return 0;}
                return ($a["ordering"] < $b["ordering"]) ? -1 : 1;
            '));


            $fields_headers = array('name'          => "Name ", 
                                    'key'           => "Key ", 
                                    'coin_value'    => "Coin ", 
                                    'timeout'       => "Timeout ",
                                    'next_cgrp_id'  => "NextCgrp ", 
                                    );
            $fields_widths = self::get_field_widths(self::$summary['keys'], $fields_headers);


            self::print_table_heading($fields_headers, $fields_widths);
            self::print_table_separator($fields_widths);
            
            $fstring = self::get_formating_string($fields_widths, "|");
            $total_coins = $total_timeout = 0;
            foreach(self::$summary['keys'] as $row){
                $total_coins += $row['coin_value'];
                $total_timeout += $row['timeout'];
                echo self::utf_8_sprintf($fstring, 
                            $row['name'], 
                            $row['key'], 
                            $row['coin_value']>0?$row['coin_value']:"---",
                            $row['timeout']>0?gmdate("H:i:s", $row['timeout']):"---",
                            $row['next_cgrp_id']?$row['next_cgrp_id']:"---");
            }

            self::print_table_separator($fields_widths);
            echo self::utf_8_sprintf($fstring, 
                        "Total:", 
                        "",
                        $total_coins,
                        self::format_time($total_timeout),
                        "");

                        
            echo "\n";
            
        }
        catch (Iquest_VerifyFailedException $e){
            fwrite(STDERR, "\nSORRY VOLE ERROR:\n");
            self::report_errors($e);
            fwrite(STDERR, "\n");
            fwrite(STDERR, $e->get_info());
            exit(1);
        }
        catch (Iquest_InvalidConfigException $e){
            fwrite(STDERR, "\nSORRY VOLE ERROR:\n");
            self::report_errors($e);
            exit(1);
        }
        catch (exception $e){
            fwrite(STDERR, "\nUnexpected exception. See PHP error log for details:\n");
            self::report_errors($e);
            throw $e;
        }

    
    
    }
    
    static function get_field_widths($fields, $fields_headers){
        $field_widths = array();
        foreach($fields_headers as $key => $val){
            $field_widths[$key] = iconv_strlen($val, "UTF-8");
            
            foreach($fields as $field){
                $width = iconv_strlen($field[$key], "UTF-8");
                if ($field_widths[$key] < $width) $field_widths[$key] = $width;
            }
        }
        
        return $field_widths;
    }
    
    static function get_formating_string($fields_widths, $separator){
        $fstr = $separator;
        
        foreach($fields_widths as $width){
            $fstr .= "%-".$width."s".$separator;
        }
        return $fstr."\n";
    }

    static function print_table_heading($fields_headers, $fields_widths){
        $format_str = self::get_formating_string($fields_widths, "^");
        $args = array_merge(array($format_str), $fields_headers);
        
        echo call_user_func_array(array('self', 'utf_8_sprintf'), $args);
    }

    static function print_table_separator($fields_widths){
        $len = 1;
        foreach($fields_widths as $width){
            $len += $width + 1;
        }

        for($i=0; $i<$len; $i++){
            echo "-";
        }
        echo "\n";
    }

}

Chroust::main();

?>
